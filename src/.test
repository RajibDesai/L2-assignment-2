/*
 bike-store/
├── src/
│   ├── app.ts
│   ├── server.ts
│   ├── app/
│       ├── config/
│       │   └── index.ts
│       ├── modules/
│           ├── interfaces/
│           │   ├── product.interface.ts
│           │   ├── order.interface.ts
│           ├── models/
│           │   ├── product.model.ts
│           │   ├── order.model.ts
│           ├── validations/
│           │   ├── product.validation.ts
│           │   ├── order.validation.ts
│           ├── servises/
│           │   ├── product.servise.ts
│           │   ├── order.servise.ts
│           ├── controllers/
│           │   ├── product.controller.ts
│           │   ├── order.controller.ts
│           ├── routes/
│           │   ├── product.route.ts
│           │   ├── order.route.ts
│           ├── middlewares/
│           │   └── error.middleware.ts
├── package.json
├── tsconfig.json
├── .env
├── README.md 

ক্লায়েন্ট > রাউটার > কন্ট্রোলার > সার্ভিস > ডেটাবেস > সার্ভিস > কন্ট্রোলার > রেসপন্স।
*/

  

/* Express Request টাইপের সাধারণ গঠন
Request এর ডিফল্ট সিগনেচার:
Request<ParamsDictionary, ResBody, ReqBody, ReqQuery, Locals>  */    
// .........................................................................................
// error.middleware.ts file

// 1. Not Found Handler
/* export const notFoundHandler = (req: Request, res: Response, next: NextFunction) => {
  res.status(404).json({
    success: false,
    message: `Cannot GET ${req.originalUrl}`,
  });
};

// 2. Error Handler
export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  _next: NextFunction
) => {
  console.error('Error Middleware:', err);

  // Handle Zod Validation Errors
  if (err instanceof ZodError) {
    const errors = err.errors.reduce((acc: any, curr: any) => {
      const path = curr.path.join('.');
      acc[path] = {
        message: curr.message,
        name: 'ValidatorError',
        properties: {
          type: curr.code,
        },
      };
      return acc;
    }, {});

    // CustomError দিয়ে নতুন ত্রুটি তৈরি করা
    const customError = new CustomError('Validation failed', 400, errors);
    console.log('customError.stack', customError.stack);
    return res.status(customError.status).json({
      message: customError.message,
      success: false,
      error: {
        name: customError.name,
        errors: customError.errors,
      },
      stack:
        process.env.NODE_ENV === 'development' ? customError.stack : undefined,
    });
  }
  // Generic error fallback / Handle Other Errors
  const customError = new CustomError(
    err.message || 'Internal Server Error',
    err.status || 500
  );
  console.log(customError.stack);
  res.status(customError.status).json({
    message: customError.message,
    success: false,
    stack:
      process.env.NODE_ENV === 'development' ? customError.stack : undefined,
  });
};
 */
// .........................................................................................


// --------------------- Another Way More Detailed Approach with custom error -------------
/* export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  _next: NextFunction
) => {
  console.error('Error Middleware:', err);

  // **Handle Zod Errors**
  if (err instanceof ZodError) {
    const errors = err.errors.reduce((acc: any, curr: any) => {
      const path = curr.path.join('.');
      acc[path] = {
        message: curr.message,
        name: 'ValidatorError',
        properties: {
          type: curr.code,
          ...(curr.minimum !== undefined && { min: curr.minimum }),
          ...(curr.options && { options: curr.options }),
        },
      };
      return acc;
    }, {});

    // CustomError ব্যবহার করে ত্রুটি তৈরি
    const customError = new CustomError('Validation failed', 400, errors);

    return res.status(customError.status).json({
      message: customError.message,
      success: false,
      error: {
        name: customError.name,
        errors: customError.errors,
      },
      stack:
        process.env.NODE_ENV === 'development' ? customError.stack : undefined,
    });
  }

  // **Handle Mongoose Validation Errors**
  if (err.name === 'ValidationError') {
    const errors = Object.keys(err.errors).reduce((acc: any, key: string) => {
      const error = err.errors[key];
      acc[key] = {
        message: error.message,
        name: 'ValidatorError',
        properties: error.properties,
      };
      return acc;
    }, {});

    // CustomError ব্যবহার করে ত্রুটি তৈরি
    const customError = new CustomError('Validation failed', 400, errors);

    return res.status(customError.status).json({
      message: customError.message,
      success: false,
      error: {
        name: customError.name,
        errors: customError.errors,
      },
      stack:
        process.env.NODE_ENV === 'development' ? customError.stack : undefined,
    });
  }

  // **Handle Other Errors (Generic Errors)**
  const customError = new CustomError(
    err.message || 'Internal Server Error',
    err.status || 500
  );

  res.status(customError.status).json({
    message: customError.message,
    success: false,
    stack:
      process.env.NODE_ENV === 'development' ? customError.stack : undefined,
  });
}; */

// ----------------------- Another Way only error.middleware.ts file -------------------
/*
export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  _next: NextFunction
) => {
  console.error('Error Middleware:', err);

  // **Handle Zod Errors**
  if (err instanceof ZodError) {
    const errors = err.errors.reduce((acc: any, curr: any) => {
      const path = curr.path.join('.');
      acc[path] = {
        message: curr.message,
        name: 'ValidatorError',
        properties: {
          type: curr.code,
          ...(curr.minimum !== undefined && { min: curr.minimum }),
          ...(curr.options && { options: curr.options }),
        },
      };
      return acc;
    }, {});

    return res.status(400).json({
      message: 'Validation failed',
      success: false,
      error: {
        name: 'ValidationError',
        errors, // Processed error details
      },
      stack:
        process.env.NODE_ENV === 'development' ? err.stack : undefined, // Stack trace only in development
    });
  }

  // **Handle Mongoose Validation Errors**
  if (err.name === 'ValidationError') {
    const errors = Object.keys(err.errors).reduce((acc: any, key: string) => {
      const error = err.errors[key];
      acc[key] = {
        message: error.message,
        name: 'ValidatorError',
        properties: error.properties,
      };
      return acc;
    }, {});

    return res.status(400).json({
      message: 'Validation failed',
      success: false,
      error: {
        name: 'ValidationError',
        errors, // Processed error details
      },
      stack:
        process.env.NODE_ENV === 'development' ? err.stack : undefined, // Stack trace only in development
    });
  }

  // **Handle Other Errors**
  res.status(err.status || 500).json({
    message: err.message || 'Internal Server Error',
    success: false,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
  });
}; */


// ..............................................................................................
/* 
           ID এর বৈধতা যাচাই করা
 if (!mongoose.isValidObjectId(productID)) {
      return res.status(400).json({
        message: 'Invalid Bike ID',
        success: false,
      });
    } */
// ..........................................................................................

/* async function-এর মূল কাজ হলো ফাংশনের ভেতরের return value-কে Promise-এর resolve value হিসেবে রিটার্ন করা।
সুতরাং, fetchSomeData JavaScript-এর Promise অবজেক্ট রিটার্ন করে।

async function fetchData() {
  return "Hello, World!";
}

const result = fetchData();
console.log(result); // এটি একটি Promise দেখাবে।

result.then((data) => console.log(data)); // "Hello, World!" দেখাবে।
fetchData() কী?
fetchData একটি async function।
async কীওয়ার্ড থাকায়, এই ফাংশন স্বয়ংক্রিয়ভাবে একটি Promise রিটার্ন করে।
ফাংশনের return স্টেটমেন্টে যা থাকে, সেটি Promise এর resolve value হয়।
২. fetchData() কীভাবে কাজ করে?
javascript
Copy
Edit
const result = fetchData();
এখানে fetchData() ফাংশন কল করা হয়েছে।
যেহেতু এটি একটি async function, এটি Promise রিটার্ন করে।
এই Promise resolve হলে তার ভ্যালু হবে "Hello, World!"।
৩. console.log(result) কী দেখাবে?
javascript
Copy
Edit
console.log(result);
এটি Promise পেন্ডিং স্টেট দেখাবে।
কারণ, fetchData() ফাংশন কল করার সাথে সাথে এর মধ্যে থাকা return স্টেটমেন্ট রানের জন্য অপেক্ষা করে।
তাই প্রথমে Promise { <pending> } দেখা যায়।
৪. result.then() কীভাবে কাজ করে?
javascript
Copy
Edit
result.then((data) => console.log(data));
এখানে .then() Promise এর resolve value অ্যাক্সেস করে।
যেহেতু fetchData ফাংশন "Hello, World!" রিটার্ন করেছে, তাই .then() সেই ভ্যালু ("Hello, World!") অ্যাক্সেস করে এবং এটি console.log(data)-এ দেখায়।
সংক্ষেপে কে কাকে কী রিটার্ন করে?
fetchData() ফাংশন: এটি Promise রিটার্ন করে।
result: এটি fetchData() ফাংশন থেকে রিটার্ন হওয়া Promise ধরে রাখে।
result.then(): এটি Promise resolve হলে তার ভ্যালু ("Hello, World!") অ্যাক্সেস করে।
কোড ফ্লো সহজ ভাষায়:
fetchData() কল করলে একটি Promise রিটার্ন হয় (যা পেন্ডিং থাকে)।
result সেই Promise ধরে রাখে।
.then() ব্যবহার করে আমরা Promise resolve হলে ভ্যালু পাই ("Hello, World!")।
*/                                   